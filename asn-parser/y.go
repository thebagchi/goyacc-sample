// Code generated by goyacc -p ASN asn.y. DO NOT EDIT.

//line asn.y:1

package main

import __yyfmt__ "fmt"

//line asn.y:3
import (
	"bytes"
	"encoding/json"
	"fmt"
	"strconv"
)

func JSON(obj interface{}) string {
	data, err := json.MarshalIndent(obj, "", "    ")
	if nil != err {
		fmt.Println("Error: ", err)
		return ""
	}
	return string(data)
}

func Print(line string) {
	fmt.Println(line)
}

func Join(values ...string) string {
	var buffer bytes.Buffer
	for _, value := range values {
		buffer.WriteString(value)
	}
	return buffer.String()
}

func SetResult(l ASNLexer, v ModuleDefinitions) {
	l.(*Parser).Result = v
}

type Empty struct{}

//line asn.y:38
type ASNSymType struct {
	yys                       int
	TypeModuleDefinitions     ModuleDefinitions
	TypeModuleDefinition      ModuleDefinition
	TypeModuleIdentifer       ModuleIdentifier
	TypeDefinitiveIdentifiers DefinitiveIdentifiers
	TypeDefinitiveIdentifier  DefinitiveIdentifier
	TypeTagDefault            TagDefault
	TypeModuleBody            ModuleBody
	TypeModuleImports         ModuleImports
	TypeModuleExports         ModuleExports
	TypeModuleImport          ModuleImport
	TypeModuleReference       ModuleReference
	TypeAssignment            Assignment
	TypeAssignments           Assignments
	TypeToken                 Empty
	TypeString                string
	TypeInteger               int
	TypeFloat                 float64
	TypeBoolean               bool
	TypeListString            []string
}

const CURLY_START = 57346
const CURLY_END = 57347
const SQUARE_START = 57348
const SQUARE_END = 57349
const DOUBLE_QUOTE = 57350
const COMMA = 57351
const COLON = 57352
const MINUS = 57353
const GREATER_THAN = 57354
const LESS_THAN = 57355
const DOT = 57356
const SLASH = 57357
const ROUND_START = 57358
const ROUND_END = 57359
const EQUALITY = 57360
const APOSTROPHE = 57361
const SPACE = 57362
const PIPE = 57363
const AT_THE_RATE = 57364
const EXCLAMATION = 57365
const CARET = 57366
const SEMI_COMMA = 57367
const ABSENT_SYMBOL = 57368
const ABSTRACTSYNTAX_SYMBOL = 57369
const ALL_SYMBOL = 57370
const APPLICATION_SYMBOL = 57371
const AUTOMATIC_SYMBOL = 57372
const BEGIN_SYMBOL = 57373
const BIT_SYMBOL = 57374
const BMPSTRING_SYMBOL = 57375
const BOOLEAN_SYMBOL = 57376
const BY_SYMBOL = 57377
const CHARACTER_SYMBOL = 57378
const CHOICE_SYMBOL = 57379
const CLASS_SYMBOL = 57380
const COMPONENT_SYMBOL = 57381
const COMPONENTS_SYMBOL = 57382
const CONSTRAINED_SYMBOL = 57383
const CONTAINING_SYMBOL = 57384
const DATE_SYMBOL = 57385
const DATETIME_SYMBOL = 57386
const DEFAULT_SYMBOL = 57387
const DEFINITIONS_SYMBOL = 57388
const DURATION_SYMBOL = 57389
const EMBEDDED_SYMBOL = 57390
const ENCODED_SYMBOL = 57391
const ENCODINGCONTROL_SYMBOL = 57392
const END_SYMBOL = 57393
const ENUMERATED_SYMBOL = 57394
const EXCEPT_SYMBOL = 57395
const EXPLICIT_SYMBOL = 57396
const EXPORTS_SYMBOL = 57397
const EXTENSIBILITY_SYMBOL = 57398
const EXTERNEL_SYMBOL = 57399
const FALSE_SYMBOL = 57400
const FROM_SYMBOL = 57401
const GENERALIZEDTIME_SYMBOL = 57402
const GENERALSTRING_SYMBOL = 57403
const GRAPHICSTRING_SYMBOL = 57404
const IA5STRING_SYMBOL = 57405
const IDENTIFIER_SYMBOL = 57406
const IMPLICIT_SYMBOL = 57407
const IMPLIED_SYMBOL = 57408
const IMPORTS_SYMBOL = 57409
const INCLUDES_SYMBOL = 57410
const INSTANCE_SYMBOL = 57411
const INSTRUCTIONS_SYMBOL = 57412
const INTEGER_SYMBOL = 57413
const INTERSECTION_SYMBOL = 57414
const ISO646STRING_SYMBOL = 57415
const MAX_SYMBOL = 57416
const MIN_SYMBOL = 57417
const MINUSINFINITY_SYMBOL = 57418
const NOTANUMBER_SYMBOL = 57419
const NULL_SYMBOL = 57420
const NUMERICSTRING_SYMBOL = 57421
const OBJECT_SYMBOL = 57422
const OBJECTDESCRIPTOR_SYMBOL = 57423
const OCTET_SYMBOL = 57424
const OF_SYMBOL = 57425
const OIDIRI_SYMBOL = 57426
const OPTIONAL_SYMBOL = 57427
const PATTERN_SYMBOL = 57428
const PDV_SYMBOL = 57429
const PLUSINFINITY_SYMBOL = 57430
const PRESENT_SYMBOL = 57431
const PRINTABLESTRING_SYMBOL = 57432
const PRIVATE_SYMBOL = 57433
const REAL_SYMBOL = 57434
const RELATIVEOID_SYMBOL = 57435
const RELATIVEOIDIRI_SYMBOL = 57436
const SEQUENCE_SYMBOL = 57437
const SET_SYMBOL = 57438
const SETTINGS_SYMBOL = 57439
const SIZE_SYMBOL = 57440
const STRING_SYMBOL = 57441
const SYNTAX_SYMBOL = 57442
const T61STRING_SYMBOL = 57443
const TAGS_SYMBOL = 57444
const TELETEXSTRING_SYMBOL = 57445
const TIME_SYMBOL = 57446
const TIMEOFDAY_SYMBOL = 57447
const TRUE_SYMBOL = 57448
const TYPEIDENTIFIER_SYMBOL = 57449
const UNION_SYMBOL = 57450
const UNIQUE_SYMBOL = 57451
const UNIVERSAL_SYMBOL = 57452
const UNIVERSALSTRING_SYMBOL = 57453
const UTCTIME_SYMBOL = 57454
const UTF8STRING_SYMBOL = 57455
const VIDEOTEXSTRING_SYMBOL = 57456
const VISIBLESTRING_SYMBOL = 57457
const WITH_SYMBOL = 57458
const ASSIGNMENT_SYMBOL = 57459
const TokenCapitalString = 57460
const TokenString = 57461
const TokenInteger = 57462
const TokenFloat = 57463
const TokenBoolean = 57464

var ASNToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"CURLY_START",
	"CURLY_END",
	"SQUARE_START",
	"SQUARE_END",
	"DOUBLE_QUOTE",
	"COMMA",
	"COLON",
	"MINUS",
	"GREATER_THAN",
	"LESS_THAN",
	"DOT",
	"SLASH",
	"ROUND_START",
	"ROUND_END",
	"EQUALITY",
	"APOSTROPHE",
	"SPACE",
	"PIPE",
	"AT_THE_RATE",
	"EXCLAMATION",
	"CARET",
	"SEMI_COMMA",
	"ABSENT_SYMBOL",
	"ABSTRACTSYNTAX_SYMBOL",
	"ALL_SYMBOL",
	"APPLICATION_SYMBOL",
	"AUTOMATIC_SYMBOL",
	"BEGIN_SYMBOL",
	"BIT_SYMBOL",
	"BMPSTRING_SYMBOL",
	"BOOLEAN_SYMBOL",
	"BY_SYMBOL",
	"CHARACTER_SYMBOL",
	"CHOICE_SYMBOL",
	"CLASS_SYMBOL",
	"COMPONENT_SYMBOL",
	"COMPONENTS_SYMBOL",
	"CONSTRAINED_SYMBOL",
	"CONTAINING_SYMBOL",
	"DATE_SYMBOL",
	"DATETIME_SYMBOL",
	"DEFAULT_SYMBOL",
	"DEFINITIONS_SYMBOL",
	"DURATION_SYMBOL",
	"EMBEDDED_SYMBOL",
	"ENCODED_SYMBOL",
	"ENCODINGCONTROL_SYMBOL",
	"END_SYMBOL",
	"ENUMERATED_SYMBOL",
	"EXCEPT_SYMBOL",
	"EXPLICIT_SYMBOL",
	"EXPORTS_SYMBOL",
	"EXTENSIBILITY_SYMBOL",
	"EXTERNEL_SYMBOL",
	"FALSE_SYMBOL",
	"FROM_SYMBOL",
	"GENERALIZEDTIME_SYMBOL",
	"GENERALSTRING_SYMBOL",
	"GRAPHICSTRING_SYMBOL",
	"IA5STRING_SYMBOL",
	"IDENTIFIER_SYMBOL",
	"IMPLICIT_SYMBOL",
	"IMPLIED_SYMBOL",
	"IMPORTS_SYMBOL",
	"INCLUDES_SYMBOL",
	"INSTANCE_SYMBOL",
	"INSTRUCTIONS_SYMBOL",
	"INTEGER_SYMBOL",
	"INTERSECTION_SYMBOL",
	"ISO646STRING_SYMBOL",
	"MAX_SYMBOL",
	"MIN_SYMBOL",
	"MINUSINFINITY_SYMBOL",
	"NOTANUMBER_SYMBOL",
	"NULL_SYMBOL",
	"NUMERICSTRING_SYMBOL",
	"OBJECT_SYMBOL",
	"OBJECTDESCRIPTOR_SYMBOL",
	"OCTET_SYMBOL",
	"OF_SYMBOL",
	"OIDIRI_SYMBOL",
	"OPTIONAL_SYMBOL",
	"PATTERN_SYMBOL",
	"PDV_SYMBOL",
	"PLUSINFINITY_SYMBOL",
	"PRESENT_SYMBOL",
	"PRINTABLESTRING_SYMBOL",
	"PRIVATE_SYMBOL",
	"REAL_SYMBOL",
	"RELATIVEOID_SYMBOL",
	"RELATIVEOIDIRI_SYMBOL",
	"SEQUENCE_SYMBOL",
	"SET_SYMBOL",
	"SETTINGS_SYMBOL",
	"SIZE_SYMBOL",
	"STRING_SYMBOL",
	"SYNTAX_SYMBOL",
	"T61STRING_SYMBOL",
	"TAGS_SYMBOL",
	"TELETEXSTRING_SYMBOL",
	"TIME_SYMBOL",
	"TIMEOFDAY_SYMBOL",
	"TRUE_SYMBOL",
	"TYPEIDENTIFIER_SYMBOL",
	"UNION_SYMBOL",
	"UNIQUE_SYMBOL",
	"UNIVERSAL_SYMBOL",
	"UNIVERSALSTRING_SYMBOL",
	"UTCTIME_SYMBOL",
	"UTF8STRING_SYMBOL",
	"VIDEOTEXSTRING_SYMBOL",
	"VISIBLESTRING_SYMBOL",
	"WITH_SYMBOL",
	"ASSIGNMENT_SYMBOL",
	"TokenCapitalString",
	"TokenString",
	"TokenInteger",
	"TokenFloat",
	"TokenBoolean",
}

var ASNStatenames = [...]string{}

const ASNEofCode = 1
const ASNErrCode = 2
const ASNInitialStackSize = 16

//line asn.y:585

//line yacctab:1
var ASNExca = [...]int{
	-1, 1,
	1, -1,
	-2, 0,
	-1, 40,
	119, 41,
	-2, 39,
	-1, 83,
	16, 8,
	-2, 56,
	-1, 87,
	16, 4,
	-2, 9,
	-1, 89,
	16, 6,
	-2, 11,
	-1, 93,
	16, 5,
	-2, 10,
	-1, 94,
	16, 7,
	-2, 12,
}

const ASNPrivate = 57344

const ASNLast = 119

var ASNAct = [...]int{
	97, 101, 102, 27, 88, 93, 94, 59, 20, 21,
	58, 6, 7, 14, 35, 56, 62, 34, 33, 32,
	26, 46, 5, 86, 78, 55, 45, 25, 38, 36,
	61, 67, 31, 45, 46, 53, 48, 54, 9, 60,
	43, 40, 44, 67, 69, 64, 47, 100, 39, 92,
	16, 24, 29, 37, 41, 90, 77, 12, 3, 68,
	1, 8, 23, 82, 81, 80, 28, 79, 76, 75,
	72, 52, 51, 85, 84, 42, 13, 30, 22, 19,
	18, 66, 17, 15, 57, 50, 49, 11, 65, 73,
	63, 70, 71, 74, 70, 10, 4, 2, 0, 0,
	83, 56, 83, 0, 91, 0, 0, 6, 7, 96,
	98, 6, 7, 87, 89, 99, 95, 20, 21,
}

var ASNPact = [...]int{
	-107, -1000, -107, -1000, -8, 53, -1000, -1000, -1000, -105,
	-1000, -1000, -111, -3, -50, -2, -1000, -1000, -1000, -1000,
	36, -1000, -24, -83, -84, -85, -1000, -1000, -1000, -106,
	43, -38, -1000, -1000, -1000, 31, 10, 44, -1000, -1000,
	-34, 28, -15, -21, -41, -104, -18, -1000, -1000, -103,
	-103, 20, -104, -1000, 22, -1000, -1000, 34, 19, -1000,
	-103, -1000, 43, -103, -1000, -1000, -107, -104, -1000, -1000,
	-1000, -1000, -1000, 52, -1000, -1000, -1000, -7, 50, -7,
	-1000, -1000, -1000, -1000, -1000, -1000, 33, -1000, -115, -1000,
	-1000, -1000, -11, -1000, -1000, 30, -1000, -119, -1000, -1000,
	-1000, -1000, -1000,
}

var ASNPgo = [...]int{
	0, 97, 58, 96, 95, 87, 83, 50, 82, 80,
	79, 39, 30, 40, 42, 29, 78, 77, 76, 75,
	22, 23, 74, 73, 37, 25, 72, 71, 35, 70,
	69, 68, 24, 67, 65, 64, 63, 60,
}

var ASNR1 = [...]int{
	0, 37, 20, 20, 21, 21, 21, 21, 21, 22,
	22, 23, 23, 1, 1, 2, 15, 3, 4, 4,
	5, 6, 6, 7, 7, 7, 8, 9, 10, 16,
	16, 16, 16, 17, 17, 18, 18, 19, 19, 19,
	13, 13, 26, 26, 27, 27, 28, 29, 30, 30,
	31, 32, 32, 33, 33, 33, 34, 35, 35, 36,
	14, 14, 14, 14, 24, 24, 25, 11, 11, 11,
	12,
}

var ASNR2 = [...]int{
	0, 1, 1, 1, 1, 2, 1, 2, 1, 1,
	2, 1, 2, 1, 2, 9, 3, 2, 1, 0,
	3, 1, 2, 1, 1, 1, 1, 1, 4, 2,
	2, 2, 0, 2, 0, 2, 0, 3, 3, 0,
	3, 0, 1, 0, 1, 2, 3, 2, 1, 0,
	3, 1, 2, 1, 1, 1, 1, 1, 1, 4,
	3, 3, 2, 0, 1, 3, 1, 1, 2, 0,
	2,
}

var ASNChk = [...]int{
	-1000, -37, -1, -2, -3, -20, 118, 119, -2, 46,
	-4, -5, 4, -18, 118, -6, -7, -8, -9, -10,
	119, 120, -16, 65, 54, 30, 70, 5, -7, 16,
	-17, 56, 102, 102, 102, 120, -15, 10, 66, 17,
	31, 10, -19, -13, -14, 67, 55, 18, 51, -14,
	-13, -26, -27, -28, -24, -25, 119, -24, 28, 25,
	-11, -12, 119, -11, 25, -28, 59, 9, 25, 25,
	-12, -15, -29, -20, -25, -30, -31, 4, -32, -33,
	-34, -35, -36, -20, -22, -23, -21, 120, 11, 121,
	5, -32, 16, 120, 121, -21, 120, 11, 121, -20,
	17, 120, 121,
}

var ASNDef = [...]int{
	0, -2, 1, 13, 0, 19, 2, 3, 14, 36,
	17, 18, 0, 32, 0, 0, 21, 23, 24, 25,
	26, 27, 34, 0, 0, 0, 35, 20, 22, 0,
	0, 0, 29, 30, 31, 0, 0, 0, 33, 28,
	-2, 0, 0, 63, 41, 43, 0, 16, 15, 69,
	69, 0, 42, 44, 0, 64, 66, 0, 0, 62,
	37, 67, 0, 38, 40, 45, 0, 0, 60, 61,
	68, 70, 46, 49, 65, 47, 48, 0, 0, 51,
	53, 54, 55, -2, 57, 58, 0, -2, 0, -2,
	50, 52, 0, -2, -2, 0, 4, 0, 6, 8,
	59, 5, 7,
}

var ASNTok1 = [...]int{
	1,
}

var ASNTok2 = [...]int{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
	52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
	62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
	72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
	82, 83, 84, 85, 86, 87, 88, 89, 90, 91,
	92, 93, 94, 95, 96, 97, 98, 99, 100, 101,
	102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
	112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
	122,
}

var ASNTok3 = [...]int{
	0,
}

var ASNErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	ASNDebug        = 0
	ASNErrorVerbose = false
)

type ASNLexer interface {
	Lex(lval *ASNSymType) int
	Error(s string)
}

type ASNParser interface {
	Parse(ASNLexer) int
	Lookahead() int
}

type ASNParserImpl struct {
	lval  ASNSymType
	stack [ASNInitialStackSize]ASNSymType
	char  int
}

func (p *ASNParserImpl) Lookahead() int {
	return p.char
}

func ASNNewParser() ASNParser {
	return &ASNParserImpl{}
}

const ASNFlag = -1000

func ASNTokname(c int) string {
	if c >= 1 && c-1 < len(ASNToknames) {
		if ASNToknames[c-1] != "" {
			return ASNToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func ASNStatname(s int) string {
	if s >= 0 && s < len(ASNStatenames) {
		if ASNStatenames[s] != "" {
			return ASNStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func ASNErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !ASNErrorVerbose {
		return "syntax error"
	}

	for _, e := range ASNErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + ASNTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := ASNPact[state]
	for tok := TOKSTART; tok-1 < len(ASNToknames); tok++ {
		if n := base + tok; n >= 0 && n < ASNLast && ASNChk[ASNAct[n]] == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if ASNDef[state] == -2 {
		i := 0
		for ASNExca[i] != -1 || ASNExca[i+1] != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; ASNExca[i] >= 0; i += 2 {
			tok := ASNExca[i]
			if tok < TOKSTART || ASNExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if ASNExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += ASNTokname(tok)
	}
	return res
}

func ASNlex1(lex ASNLexer, lval *ASNSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = ASNTok1[0]
		goto out
	}
	if char < len(ASNTok1) {
		token = ASNTok1[char]
		goto out
	}
	if char >= ASNPrivate {
		if char < ASNPrivate+len(ASNTok2) {
			token = ASNTok2[char-ASNPrivate]
			goto out
		}
	}
	for i := 0; i < len(ASNTok3); i += 2 {
		token = ASNTok3[i+0]
		if token == char {
			token = ASNTok3[i+1]
			goto out
		}
	}

out:
	if token == 0 {
		token = ASNTok2[1] /* unknown char */
	}
	if ASNDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", ASNTokname(token), uint(char))
	}
	return char, token
}

func ASNParse(ASNlex ASNLexer) int {
	return ASNNewParser().Parse(ASNlex)
}

func (ASNrcvr *ASNParserImpl) Parse(ASNlex ASNLexer) int {
	var ASNn int
	var ASNVAL ASNSymType
	var ASNDollar []ASNSymType
	_ = ASNDollar // silence set and not used
	ASNS := ASNrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	ASNstate := 0
	ASNrcvr.char = -1
	ASNtoken := -1 // ASNrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		ASNstate = -1
		ASNrcvr.char = -1
		ASNtoken = -1
	}()
	ASNp := -1
	goto ASNstack

ret0:
	return 0

ret1:
	return 1

ASNstack:
	/* put a state and value onto the stack */
	if ASNDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", ASNTokname(ASNtoken), ASNStatname(ASNstate))
	}

	ASNp++
	if ASNp >= len(ASNS) {
		nyys := make([]ASNSymType, len(ASNS)*2)
		copy(nyys, ASNS)
		ASNS = nyys
	}
	ASNS[ASNp] = ASNVAL
	ASNS[ASNp].yys = ASNstate

ASNnewstate:
	ASNn = ASNPact[ASNstate]
	if ASNn <= ASNFlag {
		goto ASNdefault /* simple state */
	}
	if ASNrcvr.char < 0 {
		ASNrcvr.char, ASNtoken = ASNlex1(ASNlex, &ASNrcvr.lval)
	}
	ASNn += ASNtoken
	if ASNn < 0 || ASNn >= ASNLast {
		goto ASNdefault
	}
	ASNn = ASNAct[ASNn]
	if ASNChk[ASNn] == ASNtoken { /* valid shift */
		ASNrcvr.char = -1
		ASNtoken = -1
		ASNVAL = ASNrcvr.lval
		ASNstate = ASNn
		if Errflag > 0 {
			Errflag--
		}
		goto ASNstack
	}

ASNdefault:
	/* default state action */
	ASNn = ASNDef[ASNstate]
	if ASNn == -2 {
		if ASNrcvr.char < 0 {
			ASNrcvr.char, ASNtoken = ASNlex1(ASNlex, &ASNrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if ASNExca[xi+0] == -1 && ASNExca[xi+1] == ASNstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			ASNn = ASNExca[xi+0]
			if ASNn < 0 || ASNn == ASNtoken {
				break
			}
		}
		ASNn = ASNExca[xi+1]
		if ASNn < 0 {
			goto ret0
		}
	}
	if ASNn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			ASNlex.Error(ASNErrorMessage(ASNstate, ASNtoken))
			Nerrs++
			if ASNDebug >= 1 {
				__yyfmt__.Printf("%s", ASNStatname(ASNstate))
				__yyfmt__.Printf(" saw %s\n", ASNTokname(ASNtoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for ASNp >= 0 {
				ASNn = ASNPact[ASNS[ASNp].yys] + ASNErrCode
				if ASNn >= 0 && ASNn < ASNLast {
					ASNstate = ASNAct[ASNn] /* simulate a shift of "error" */
					if ASNChk[ASNstate] == ASNErrCode {
						goto ASNstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if ASNDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", ASNS[ASNp].yys)
				}
				ASNp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if ASNDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", ASNTokname(ASNtoken))
			}
			if ASNtoken == ASNEofCode {
				goto ret1
			}
			ASNrcvr.char = -1
			ASNtoken = -1
			goto ASNnewstate /* try again in the same state */
		}
	}

	/* reduction by production ASNn */
	if ASNDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", ASNn, ASNStatname(ASNstate))
	}

	ASNnt := ASNn
	ASNpt := ASNp
	_ = ASNpt // guard against "declared and not used"

	ASNp -= ASNR2[ASNn]
	// ASNp is now the index of $0. Perform the default action. Iff the
	// reduced production is Îµ, $1 is possibly out of range.
	if ASNp+1 >= len(ASNS) {
		nyys := make([]ASNSymType, len(ASNS)*2)
		copy(nyys, ASNS)
		ASNS = nyys
	}
	ASNVAL = ASNS[ASNp+1]

	/* consult goto table to find next state */
	ASNn = ASNR1[ASNn]
	ASNg := ASNPgo[ASNn]
	ASNj := ASNg + ASNS[ASNp].yys + 1

	if ASNj >= ASNLast {
		ASNstate = ASNAct[ASNg]
	} else {
		ASNstate = ASNAct[ASNj]
		if ASNChk[ASNstate] != -ASNn {
			ASNstate = ASNAct[ASNg]
		}
	}
	// dummy call; replaced with literal code
	switch ASNnt {

	case 1:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:225
		{
			SetResult(ASNlex, ASNDollar[1].TypeModuleDefinitions)
			Print("Done")
			Print("--------------------------------------------------------------------------------")
			Print(JSON(&ASNDollar[1].TypeModuleDefinitions))
			Print("--------------------------------------------------------------------------------")
		}
	case 2:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:234
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	case 3:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:237
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	case 4:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:242
		{
			ASNVAL.TypeString = strconv.Itoa(ASNDollar[1].TypeInteger)
		}
	case 5:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:245
		{
			ASNVAL.TypeString = strconv.Itoa((-1) * ASNDollar[2].TypeInteger)
		}
	case 6:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:248
		{
			ASNVAL.TypeString = strconv.FormatFloat(ASNDollar[1].TypeFloat, 'f', -1, 64)
		}
	case 7:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:251
		{
			ASNVAL.TypeString = strconv.FormatFloat(((-1) * ASNDollar[2].TypeFloat), 'f', -1, 64)
		}
	case 8:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:254
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	case 9:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:259
		{
			ASNVAL.TypeInteger = ASNDollar[1].TypeInteger
		}
	case 10:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:262
		{
			ASNVAL.TypeInteger = (-1) * ASNDollar[2].TypeInteger
		}
	case 11:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:267
		{
			ASNVAL.TypeFloat = ASNDollar[1].TypeFloat
		}
	case 12:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:270
		{
			ASNVAL.TypeFloat = (-1) * ASNDollar[2].TypeFloat
		}
	case 13:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:275
		{
			ASNVAL.TypeModuleDefinitions = []ModuleDefinition{
				ASNDollar[1].TypeModuleDefinition,
			}
		}
	case 14:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:280
		{
			ASNVAL.TypeModuleDefinitions = ASNDollar[1].TypeModuleDefinitions
			ASNVAL.TypeModuleDefinitions = append(ASNVAL.TypeModuleDefinitions, ASNDollar[2].TypeModuleDefinition)
		}
	case 15:
		ASNDollar = ASNS[ASNpt-9 : ASNpt+1]
//line asn.y:295
		{
			ASNVAL.TypeModuleDefinition = ModuleDefinition{
				Identifier: ASNDollar[1].TypeModuleIdentifer,
				Body:       ASNDollar[8].TypeModuleBody,
			}
		}
	case 16:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line asn.y:303
		{
			ASNVAL.TypeString = "::="
		}
	case 17:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:310
		{
			ASNVAL.TypeModuleIdentifer = ModuleIdentifier{
				Reference:             ASNDollar[1].TypeString,
				DefinitiveIdentifiers: ASNDollar[2].TypeDefinitiveIdentifiers,
			}
		}
	case 18:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:318
		{
			ASNVAL.TypeDefinitiveIdentifiers = ASNDollar[1].TypeDefinitiveIdentifiers
		}
	case 19:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line asn.y:321
		{
			ASNVAL.TypeDefinitiveIdentifiers = make(DefinitiveIdentifiers, 0)
		}
	case 20:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line asn.y:326
		{
			ASNVAL.TypeDefinitiveIdentifiers = ASNDollar[2].TypeDefinitiveIdentifiers
		}
	case 21:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:331
		{
			ASNVAL.TypeDefinitiveIdentifiers = []DefinitiveIdentifier{
				ASNDollar[1].TypeDefinitiveIdentifier,
			}
		}
	case 22:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:336
		{
			ASNVAL.TypeDefinitiveIdentifiers = ASNDollar[1].TypeDefinitiveIdentifiers
			ASNVAL.TypeDefinitiveIdentifiers = append(ASNVAL.TypeDefinitiveIdentifiers, ASNDollar[2].TypeDefinitiveIdentifier)
		}
	case 23:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:342
		{
			ASNVAL.TypeDefinitiveIdentifier = ASNDollar[1].TypeDefinitiveIdentifier
		}
	case 24:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:345
		{
			ASNVAL.TypeDefinitiveIdentifier = ASNDollar[1].TypeDefinitiveIdentifier
		}
	case 25:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:348
		{
			ASNVAL.TypeDefinitiveIdentifier = ASNDollar[1].TypeDefinitiveIdentifier
		}
	case 26:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:353
		{
			ASNVAL.TypeDefinitiveIdentifier = DefinitiveIdentifier{
				Name: ASNDollar[1].TypeString,
			}
		}
	case 27:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:360
		{
			ASNVAL.TypeDefinitiveIdentifier = DefinitiveIdentifier{
				Id: ASNDollar[1].TypeInteger,
			}
		}
	case 28:
		ASNDollar = ASNS[ASNpt-4 : ASNpt+1]
//line asn.y:367
		{
			ASNVAL.TypeDefinitiveIdentifier = DefinitiveIdentifier{
				Name: ASNDollar[1].TypeString,
				Id:   ASNDollar[3].TypeInteger,
			}
		}
	case 29:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:375
		{
			ASNVAL.TypeTagDefault = ImplicitTag
		}
	case 30:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:378
		{
			ASNVAL.TypeTagDefault = ExplicitTag
		}
	case 31:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:381
		{
			ASNVAL.TypeTagDefault = AutomaticTag
		}
	case 32:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line asn.y:384
		{
			ASNVAL.TypeTagDefault = ExplicitTag
		}
	case 33:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:389
		{
			ASNVAL.TypeBoolean = true
		}
	case 34:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line asn.y:392
		{
			ASNVAL.TypeBoolean = false
		}
	case 35:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:397
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	case 36:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line asn.y:400
		{
			ASNVAL.TypeString = ""
		}
	case 37:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line asn.y:407
		{
			ASNVAL.TypeModuleBody = ModuleBody{
				Imports: ASNDollar[1].TypeModuleImports,
				Exports: ASNDollar[2].TypeModuleExports,
			}
		}
	case 38:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line asn.y:415
		{
			ASNVAL.TypeModuleBody = ModuleBody{
				Imports: ASNDollar[2].TypeModuleImports,
				Exports: ASNDollar[1].TypeModuleExports,
			}
		}
	case 39:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line asn.y:421
		{
			ASNVAL.TypeModuleBody = ModuleBody{
				// Empty
			}
		}
	case 40:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line asn.y:428
		{
			ASNVAL.TypeModuleImports = ASNDollar[2].TypeModuleImports
		}
	case 41:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line asn.y:431
		{
			ASNVAL.TypeModuleImports = []ModuleImport{
				// EMPTY
			}
		}
	case 42:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:438
		{
			ASNVAL.TypeModuleImports = ASNDollar[1].TypeModuleImports
		}
	case 43:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line asn.y:441
		{
			ASNVAL.TypeModuleImports = []ModuleImport{
				// EMPTY
			}
		}
	case 44:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:448
		{
			ASNVAL.TypeModuleImports = []ModuleImport{
				ASNDollar[1].TypeModuleImport,
			}
		}
	case 45:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:453
		{
			ASNVAL.TypeModuleImports = ASNDollar[1].TypeModuleImports
			ASNVAL.TypeModuleImports = append(ASNVAL.TypeModuleImports, ASNDollar[2].TypeModuleImport)
		}
	case 46:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line asn.y:459
		{
			ASNVAL.TypeModuleImport = ModuleImport{
				Symbols:   ASNDollar[1].TypeListString,
				Reference: ASNDollar[3].TypeModuleReference,
			}
		}
	case 47:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:467
		{
			ASNVAL.TypeModuleReference = ModuleReference{
				Identifier:          ASNDollar[1].TypeString,
				AssignedIdentifiers: ASNDollar[2].TypeString,
			}
		}
	case 48:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:475
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	case 49:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line asn.y:478
		{
			ASNVAL.TypeString = ""
		}
	case 50:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line asn.y:483
		{
			ASNVAL.TypeString = Join("{", ASNDollar[2].TypeString, "}")
		}
	case 51:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:488
		{
			ASNVAL.TypeString = Join("", ASNDollar[1].TypeString)
		}
	case 52:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:491
		{
			ASNVAL.TypeString = Join(ASNDollar[1].TypeString, " ", ASNDollar[2].TypeString)
		}
	case 53:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:496
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	case 54:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:499
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	case 55:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:502
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	case 56:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:507
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	case 57:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:512
		{
			ASNVAL.TypeString = strconv.Itoa(ASNDollar[1].TypeInteger)
		}
	case 58:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:515
		{
			ASNVAL.TypeString = strconv.FormatFloat(ASNDollar[1].TypeFloat, 'f', -1, 64)
		}
	case 59:
		ASNDollar = ASNS[ASNpt-4 : ASNpt+1]
//line asn.y:520
		{
			ASNVAL.TypeString = Join(ASNDollar[1].TypeString, "(", ASNDollar[3].TypeString, ")")
		}
	case 60:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line asn.y:525
		{
			ASNVAL.TypeModuleExports = ModuleExports{
				All:     false,
				Symbols: ASNDollar[2].TypeListString,
			}
		}
	case 61:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line asn.y:531
		{
			ASNVAL.TypeModuleExports = ModuleExports{
				All: true,
			}
		}
	case 62:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:536
		{
			ASNVAL.TypeModuleExports = ModuleExports{
				// Empty
			}
		}
	case 63:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line asn.y:541
		{
			ASNVAL.TypeModuleExports = ModuleExports{
				// Empty
			}
		}
	case 64:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:548
		{
			ASNVAL.TypeListString = []string{
				ASNDollar[1].TypeString,
			}
		}
	case 65:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line asn.y:553
		{
			ASNVAL.TypeListString = ASNDollar[1].TypeListString
			ASNVAL.TypeListString = append(ASNVAL.TypeListString, ASNDollar[3].TypeString)
		}
	case 66:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:559
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	case 67:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line asn.y:564
		{
			ASNVAL.TypeAssignments = []Assignment{
				ASNDollar[1].TypeAssignment,
			}
		}
	case 68:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:569
		{
			ASNVAL.TypeAssignments = ASNDollar[1].TypeAssignments
			ASNVAL.TypeAssignments = append(ASNVAL.TypeAssignments, ASNDollar[2].TypeAssignment)
		}
	case 69:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line asn.y:573
		{
			ASNVAL.TypeAssignments = []Assignment{
				// Empty
			}
		}
	case 70:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line asn.y:580
		{
			ASNVAL.TypeAssignment = Assignment{
				// Empty
			}
		}
	}
	goto ASNstack /* stack new state and value */
}
