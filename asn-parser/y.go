// Code generated by goyacc -p ASN yacc.y. DO NOT EDIT.

//line yacc.y:2
package main

import __yyfmt__ "fmt"

//line yacc.y:2
func SetResult(l ASNLexer, v ModuleDefinitions) {
	l.(*Parser).Result = v
}

type Empty struct{}

//line yacc.y:9
type ASNSymType struct {
	yys                       int
	TypeModuleDefinitions     ModuleDefinitions
	TypeModuleDefinition      ModuleDefinition
	TypeModuleIdentifer       ModuleIdentifier
	TypeDefinitiveIdentifiers DefinitiveIdentifiers
	TypeDefinitiveIdentifier  DefinitiveIdentifier
	TypeTagDefault            TagDefault
	TypeModuleBody            ModuleBody
	TypeModuleImports         ModuleImports
	TypeModuleExports         ModuleExports
	TypeToken                 Empty
	TypeString                string
	TypeInteger               int
	TypeFloat                 float64
	TypeBoolean               bool
	TypeListString            []string
}

const CURLY_START = 57346
const CURLY_END = 57347
const SQUARE_START = 57348
const SQUARE_END = 57349
const DOUBLE_QUOTE = 57350
const COMMA = 57351
const COLON = 57352
const MINUS = 57353
const GREATER_THAN = 57354
const LESS_THAN = 57355
const DOT = 57356
const SLASH = 57357
const ROUND_START = 57358
const ROUND_END = 57359
const EQUALITY = 57360
const APOSTROPHE = 57361
const SPACE = 57362
const PIPE = 57363
const AT_THE_RATE = 57364
const EXCLAMATION = 57365
const CARET = 57366
const SEMI_COMMA = 57367
const DEFINITIONS_SYMBOL = 57368
const ASSIGNMENT_SYMBOL = 57369
const BEGIN_SYMBOL = 57370
const END_SYMBOL = 57371
const INSTRUCTIONS_SYMBOL = 57372
const EXPLICIT_SYMBOL = 57373
const IMPLICIT_SYMBOL = 57374
const AUTOMATIC_SYMBOL = 57375
const TAGS_SYMBOL = 57376
const EXTENSIBILITY_SYMBOL = 57377
const IMPLIED_SYMBOL = 57378
const EXPORTS_SYMBOL = 57379
const IMPORTS_SYMBOL = 57380
const ALL_SYMBOL = 57381
const TokenString = 57382
const TokenInteger = 57383
const TokenFloat = 57384
const TokenBoolean = 57385

var ASNToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"CURLY_START",
	"CURLY_END",
	"SQUARE_START",
	"SQUARE_END",
	"DOUBLE_QUOTE",
	"COMMA",
	"COLON",
	"MINUS",
	"GREATER_THAN",
	"LESS_THAN",
	"DOT",
	"SLASH",
	"ROUND_START",
	"ROUND_END",
	"EQUALITY",
	"APOSTROPHE",
	"SPACE",
	"PIPE",
	"AT_THE_RATE",
	"EXCLAMATION",
	"CARET",
	"SEMI_COMMA",
	"DEFINITIONS_SYMBOL",
	"ASSIGNMENT_SYMBOL",
	"BEGIN_SYMBOL",
	"END_SYMBOL",
	"INSTRUCTIONS_SYMBOL",
	"EXPLICIT_SYMBOL",
	"IMPLICIT_SYMBOL",
	"AUTOMATIC_SYMBOL",
	"TAGS_SYMBOL",
	"EXTENSIBILITY_SYMBOL",
	"IMPLIED_SYMBOL",
	"EXPORTS_SYMBOL",
	"IMPORTS_SYMBOL",
	"ALL_SYMBOL",
	"TokenString",
	"TokenInteger",
	"TokenFloat",
	"TokenBoolean",
}

var ASNStatenames = [...]string{}

const ASNEofCode = 1
const ASNErrCode = 2
const ASNInitialStackSize = 16

//line yacc.y:295

//line yacctab:1
var ASNExca = [...]int{
	-1, 1,
	1, -1,
	-2, 0,
}

const ASNPrivate = 57344

const ASNLast = 55

var ASNAct = [...]int{
	46, 25, 18, 19, 44, 47, 29, 33, 47, 12,
	5, 40, 35, 22, 21, 23, 24, 32, 31, 30,
	41, 37, 34, 7, 50, 49, 36, 27, 14, 51,
	10, 3, 1, 45, 6, 43, 18, 19, 48, 39,
	42, 38, 26, 28, 20, 11, 17, 16, 15, 13,
	9, 8, 52, 4, 2,
}

var ASNPact = [...]int{
	-30, -1000, -30, -1000, -3, 26, -1000, -31, -1000, -1000,
	-38, -18, -14, -4, -1000, -1000, -1000, -1000, 11, -1000,
	-29, -15, -16, -17, -1000, -1000, -1000, -34, -5, -24,
	-1000, -1000, -1000, 9, -7, -1000, -1000, -26, -9, -1000,
	-35, -1000, -1000, 0, -1, 20, -1000, -1000, -1000, -1000,
	-1000, -32, -1000,
}

var ASNPgo = [...]int{
	0, 54, 31, 53, 51, 50, 49, 28, 48, 47,
	46, 45, 44, 43, 41, 40, 39, 38, 35, 33,
	0, 32,
}

var ASNR1 = [...]int{
	0, 21, 1, 1, 2, 3, 4, 4, 5, 6,
	6, 7, 7, 7, 8, 9, 10, 11, 11, 12,
	12, 12, 12, 13, 13, 14, 15, 16, 16, 16,
	17, 18, 18, 19, 19, 20,
}

var ASNR2 = [...]int{
	0, 1, 1, 2, 9, 2, 1, 0, 3, 1,
	2, 1, 1, 1, 1, 1, 4, 2, 0, 2,
	2, 2, 0, 2, 0, 3, 0, 3, 3, 0,
	0, 1, 0, 1, 3, 1,
}

var ASNChk = [...]int{
	-1000, -21, -1, -2, -3, 40, -2, 26, -4, -5,
	4, -11, 40, -6, -7, -8, -9, -10, 40, 41,
	-12, 32, 31, 33, 30, 5, -7, 16, -13, 35,
	34, 34, 34, 41, 27, 36, 17, 28, -14, -16,
	37, 29, -15, -18, 39, -19, -20, 40, -17, 25,
	25, 9, -20,
}

var ASNDef = [...]int{
	0, -2, 1, 2, 0, 7, 3, 18, 5, 6,
	0, 22, 0, 0, 9, 11, 12, 13, 14, 15,
	24, 0, 0, 0, 17, 8, 10, 0, 0, 0,
	19, 20, 21, 0, 0, 23, 16, 29, 0, 26,
	32, 4, 30, 0, 0, 31, 33, 35, 25, 27,
	28, 0, 34,
}

var ASNTok1 = [...]int{
	1,
}

var ASNTok2 = [...]int{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
	42, 43,
}

var ASNTok3 = [...]int{
	0,
}

var ASNErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	ASNDebug        = 1
	ASNErrorVerbose = true
)

type ASNLexer interface {
	Lex(lval *ASNSymType) int
	Error(s string)
}

type ASNParser interface {
	Parse(ASNLexer) int
	Lookahead() int
}

type ASNParserImpl struct {
	lval  ASNSymType
	stack [ASNInitialStackSize]ASNSymType
	char  int
}

func (p *ASNParserImpl) Lookahead() int {
	return p.char
}

func ASNNewParser() ASNParser {
	return &ASNParserImpl{}
}

const ASNFlag = -1000

func ASNTokname(c int) string {
	if c >= 1 && c-1 < len(ASNToknames) {
		if ASNToknames[c-1] != "" {
			return ASNToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func ASNStatname(s int) string {
	if s >= 0 && s < len(ASNStatenames) {
		if ASNStatenames[s] != "" {
			return ASNStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func ASNErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !ASNErrorVerbose {
		return "syntax error"
	}

	for _, e := range ASNErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + ASNTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := ASNPact[state]
	for tok := TOKSTART; tok-1 < len(ASNToknames); tok++ {
		if n := base + tok; n >= 0 && n < ASNLast && ASNChk[ASNAct[n]] == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if ASNDef[state] == -2 {
		i := 0
		for ASNExca[i] != -1 || ASNExca[i+1] != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; ASNExca[i] >= 0; i += 2 {
			tok := ASNExca[i]
			if tok < TOKSTART || ASNExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if ASNExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += ASNTokname(tok)
	}
	return res
}

func ASNlex1(lex ASNLexer, lval *ASNSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = ASNTok1[0]
		goto out
	}
	if char < len(ASNTok1) {
		token = ASNTok1[char]
		goto out
	}
	if char >= ASNPrivate {
		if char < ASNPrivate+len(ASNTok2) {
			token = ASNTok2[char-ASNPrivate]
			goto out
		}
	}
	for i := 0; i < len(ASNTok3); i += 2 {
		token = ASNTok3[i+0]
		if token == char {
			token = ASNTok3[i+1]
			goto out
		}
	}

out:
	if token == 0 {
		token = ASNTok2[1] /* unknown char */
	}
	if ASNDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", ASNTokname(token), uint(char))
	}
	return char, token
}

func ASNParse(ASNlex ASNLexer) int {
	return ASNNewParser().Parse(ASNlex)
}

func (ASNrcvr *ASNParserImpl) Parse(ASNlex ASNLexer) int {
	var ASNn int
	var ASNVAL ASNSymType
	var ASNDollar []ASNSymType
	_ = ASNDollar // silence set and not used
	ASNS := ASNrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	ASNstate := 0
	ASNrcvr.char = -1
	ASNtoken := -1 // ASNrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		ASNstate = -1
		ASNrcvr.char = -1
		ASNtoken = -1
	}()
	ASNp := -1
	goto ASNstack

ret0:
	return 0

ret1:
	return 1

ASNstack:
	/* put a state and value onto the stack */
	if ASNDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", ASNTokname(ASNtoken), ASNStatname(ASNstate))
	}

	ASNp++
	if ASNp >= len(ASNS) {
		nyys := make([]ASNSymType, len(ASNS)*2)
		copy(nyys, ASNS)
		ASNS = nyys
	}
	ASNS[ASNp] = ASNVAL
	ASNS[ASNp].yys = ASNstate

ASNnewstate:
	ASNn = ASNPact[ASNstate]
	if ASNn <= ASNFlag {
		goto ASNdefault /* simple state */
	}
	if ASNrcvr.char < 0 {
		ASNrcvr.char, ASNtoken = ASNlex1(ASNlex, &ASNrcvr.lval)
	}
	ASNn += ASNtoken
	if ASNn < 0 || ASNn >= ASNLast {
		goto ASNdefault
	}
	ASNn = ASNAct[ASNn]
	if ASNChk[ASNn] == ASNtoken { /* valid shift */
		ASNrcvr.char = -1
		ASNtoken = -1
		ASNVAL = ASNrcvr.lval
		ASNstate = ASNn
		if Errflag > 0 {
			Errflag--
		}
		goto ASNstack
	}

ASNdefault:
	/* default state action */
	ASNn = ASNDef[ASNstate]
	if ASNn == -2 {
		if ASNrcvr.char < 0 {
			ASNrcvr.char, ASNtoken = ASNlex1(ASNlex, &ASNrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if ASNExca[xi+0] == -1 && ASNExca[xi+1] == ASNstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			ASNn = ASNExca[xi+0]
			if ASNn < 0 || ASNn == ASNtoken {
				break
			}
		}
		ASNn = ASNExca[xi+1]
		if ASNn < 0 {
			goto ret0
		}
	}
	if ASNn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			ASNlex.Error(ASNErrorMessage(ASNstate, ASNtoken))
			Nerrs++
			if ASNDebug >= 1 {
				__yyfmt__.Printf("%s", ASNStatname(ASNstate))
				__yyfmt__.Printf(" saw %s\n", ASNTokname(ASNtoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for ASNp >= 0 {
				ASNn = ASNPact[ASNS[ASNp].yys] + ASNErrCode
				if ASNn >= 0 && ASNn < ASNLast {
					ASNstate = ASNAct[ASNn] /* simulate a shift of "error" */
					if ASNChk[ASNstate] == ASNErrCode {
						goto ASNstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if ASNDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", ASNS[ASNp].yys)
				}
				ASNp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if ASNDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", ASNTokname(ASNtoken))
			}
			if ASNtoken == ASNEofCode {
				goto ret1
			}
			ASNrcvr.char = -1
			ASNtoken = -1
			goto ASNnewstate /* try again in the same state */
		}
	}

	/* reduction by production ASNn */
	if ASNDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", ASNn, ASNStatname(ASNstate))
	}

	ASNnt := ASNn
	ASNpt := ASNp
	_ = ASNpt // guard against "declared and not used"

	ASNp -= ASNR2[ASNn]
	// ASNp is now the index of $0. Perform the default action. Iff the
	// reduced production is Îµ, $1 is possibly out of range.
	if ASNp+1 >= len(ASNS) {
		nyys := make([]ASNSymType, len(ASNS)*2)
		copy(nyys, ASNS)
		ASNS = nyys
	}
	ASNVAL = ASNS[ASNp+1]

	/* consult goto table to find next state */
	ASNn = ASNR1[ASNn]
	ASNg := ASNPgo[ASNn]
	ASNj := ASNg + ASNS[ASNp].yys + 1

	if ASNj >= ASNLast {
		ASNstate = ASNAct[ASNg]
	} else {
		ASNstate = ASNAct[ASNj]
		if ASNChk[ASNstate] != -ASNn {
			ASNstate = ASNAct[ASNg]
		}
	}
	// dummy call; replaced with literal code
	switch ASNnt {

	case 1:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:96
		{
			SetResult(ASNlex, ASNDollar[1].TypeModuleDefinitions)
		}
	case 2:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:101
		{
			ASNVAL.TypeModuleDefinitions = []ModuleDefinition{
				ASNDollar[1].TypeModuleDefinition,
			}
		}
	case 3:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line yacc.y:106
		{
			ASNVAL.TypeModuleDefinitions = ASNDollar[1].TypeModuleDefinitions
			ASNVAL.TypeModuleDefinitions = append(ASNVAL.TypeModuleDefinitions, ASNDollar[2].TypeModuleDefinition)
		}
	case 4:
		ASNDollar = ASNS[ASNpt-9 : ASNpt+1]
//line yacc.y:121
		{
			ASNVAL.TypeModuleDefinition = ModuleDefinition{
				Identifier:        ASNDollar[1].TypeModuleIdentifer,
				EncodingReference: ASNDollar[3].TypeString,
				Tag:               ASNDollar[4].TypeTagDefault,
				Extensibility:     ASNDollar[5].TypeBoolean,
				Body:              ASNDollar[8].TypeModuleBody,
			}
		}
	case 5:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line yacc.y:134
		{
			ASNVAL.TypeModuleIdentifer = ModuleIdentifier{
				Reference:             ASNDollar[1].TypeString,
				DefinitiveIdentifiers: ASNDollar[2].TypeDefinitiveIdentifiers,
			}
		}
	case 6:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:142
		{
			ASNVAL.TypeDefinitiveIdentifiers = ASNDollar[1].TypeDefinitiveIdentifiers
		}
	case 7:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line yacc.y:145
		{
			ASNVAL.TypeDefinitiveIdentifiers = make(DefinitiveIdentifiers, 0)
		}
	case 8:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line yacc.y:150
		{
			ASNVAL.TypeDefinitiveIdentifiers = ASNDollar[2].TypeDefinitiveIdentifiers
		}
	case 9:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:155
		{
			ASNVAL.TypeDefinitiveIdentifiers = []DefinitiveIdentifier{
				ASNDollar[1].TypeDefinitiveIdentifier,
			}
		}
	case 10:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line yacc.y:160
		{
			ASNVAL.TypeDefinitiveIdentifiers = ASNDollar[1].TypeDefinitiveIdentifiers
			ASNVAL.TypeDefinitiveIdentifiers = append(ASNVAL.TypeDefinitiveIdentifiers, ASNDollar[2].TypeDefinitiveIdentifier)
		}
	case 11:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:166
		{
			ASNVAL.TypeDefinitiveIdentifier = ASNDollar[1].TypeDefinitiveIdentifier
		}
	case 12:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:169
		{
			ASNVAL.TypeDefinitiveIdentifier = ASNDollar[1].TypeDefinitiveIdentifier
		}
	case 13:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:172
		{
			ASNVAL.TypeDefinitiveIdentifier = ASNDollar[1].TypeDefinitiveIdentifier
		}
	case 14:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:177
		{
			ASNVAL.TypeDefinitiveIdentifier = DefinitiveIdentifier{
				Name: ASNDollar[1].TypeString,
			}
		}
	case 15:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:184
		{
			ASNVAL.TypeDefinitiveIdentifier = DefinitiveIdentifier{
				Id: ASNDollar[1].TypeInteger,
			}
		}
	case 16:
		ASNDollar = ASNS[ASNpt-4 : ASNpt+1]
//line yacc.y:191
		{
			ASNVAL.TypeDefinitiveIdentifier = DefinitiveIdentifier{
				Name: ASNDollar[1].TypeString,
				Id:   ASNDollar[3].TypeInteger,
			}
		}
	case 17:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line yacc.y:199
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	case 18:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line yacc.y:202
		{
			ASNVAL.TypeString = ""
		}
	case 19:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line yacc.y:207
		{
			ASNVAL.TypeTagDefault = ImplicitTag
		}
	case 20:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line yacc.y:210
		{
			ASNVAL.TypeTagDefault = ExplicitTag
		}
	case 21:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line yacc.y:213
		{
			ASNVAL.TypeTagDefault = AutomaticTag
		}
	case 22:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line yacc.y:216
		{
			ASNVAL.TypeTagDefault = ExplicitTag
		}
	case 23:
		ASNDollar = ASNS[ASNpt-2 : ASNpt+1]
//line yacc.y:221
		{
			ASNVAL.TypeBoolean = true
		}
	case 24:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line yacc.y:224
		{
			ASNVAL.TypeBoolean = false
		}
	case 25:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line yacc.y:231
		{
			ASNVAL.TypeModuleBody = ModuleBody{
				Exports: ASNDollar[1].TypeModuleExports,
				Imports: ASNDollar[2].TypeModuleImports,
			}
		}
	case 26:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line yacc.y:239
		{
			ASNVAL.TypeModuleImports = ModuleImports{
				//Empty
			}
		}
	case 27:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line yacc.y:246
		{
			ASNVAL.TypeModuleExports = ModuleExports{
				Symbols: ASNDollar[2].TypeListString,
				All:     false,
			}
		}
	case 28:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line yacc.y:252
		{
			ASNVAL.TypeModuleExports = ModuleExports{
				All: true,
			}
		}
	case 29:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line yacc.y:257
		{
			ASNVAL.TypeModuleExports = ModuleExports{
				//Empty
			}
		}
	case 30:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line yacc.y:264
		{
			ASNVAL.TypeString = ""
		}
	case 31:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:269
		{
			ASNVAL.TypeListString = ASNDollar[1].TypeListString
		}
	case 32:
		ASNDollar = ASNS[ASNpt-0 : ASNpt+1]
//line yacc.y:272
		{
			ASNVAL.TypeListString = []string{
				// Empty
			}
		}
	case 33:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:279
		{
			ASNVAL.TypeListString = []string{
				ASNDollar[1].TypeString,
			}
		}
	case 34:
		ASNDollar = ASNS[ASNpt-3 : ASNpt+1]
//line yacc.y:284
		{
			ASNVAL.TypeListString = ASNDollar[1].TypeListString
			ASNVAL.TypeListString = append(ASNVAL.TypeListString, ASNDollar[3].TypeString)
		}
	case 35:
		ASNDollar = ASNS[ASNpt-1 : ASNpt+1]
//line yacc.y:290
		{
			ASNVAL.TypeString = ASNDollar[1].TypeString
		}
	}
	goto ASNstack /* stack new state and value */
}
